import pandas as pd
import numpy as np
from sklearn.preprocessing import StandardScaler, OneHotEncoder
from sklearn.compose import ColumnTransformer
from loguru import logger  # For logging information, warnings, and errors
from .utils import memory_optimize  # Utility function to optimize DataFrame memory usage

class DataPreprocessor:
    def __init__(self):
        # Initialize variables for the preprocessor and feature names.
        self.preprocessor = None  
        self.feature_names = []  # To store the names of features after encoding
    
    def preprocess(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        Full preprocessing pipeline that:
        1. Encodes categorical features.
        2. Normalizes numerical features.
        3. Handles skewness in numerical features.
        4. Optimizes DataFrame memory usage.
        
        :param df: Input DataFrame.
        :return: Processed DataFrame.
        """
        logger.info("Starting data preprocessing")
        # Encode categorical features using one-hot encoding (sparse DataFrame output)
        df = self._encode_categoricals(df)
        # Normalize numerical features using StandardScaler
        df = self._normalize_numerical(df)
        # Apply logarithmic transformation to highly skewed numerical features
        df = self._handle_skewness(df)
        # Optimize DataFrame memory usage (e.g., reducing data types)
        df = memory_optimize(df)
        logger.success("Completed preprocessing")
        return df
    
    def _encode_categoricals(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        Encodes categorical features using one-hot encoding.
        
        - Selects columns of type 'category' or 'object'.
        - Uses ColumnTransformer with OneHotEncoder to convert these columns into binary indicators.
        - The remainder of the DataFrame (non-categorical columns) is passed through unchanged.
        - Stores the new feature names after transformation.
        - Returns a sparse DataFrame to preserve memory.
        
        :param df: Input DataFrame.
        :return: DataFrame with categorical features encoded.
        """
        # Select columns of type 'object' or 'category'
        cat_cols = df.select_dtypes(include=['category', 'object']).columns
        
        # Create a ColumnTransformer that applies OneHotEncoder to the categorical columns.
        # Use `sparse_output=True` (for scikit-learn >=1.2) to keep output sparse.
        preprocessor = ColumnTransformer(
            transformers=[
                ('onehot', OneHotEncoder(handle_unknown='ignore', sparse_output=True), cat_cols)
            ],
            remainder='passthrough'
        )
        
        # Fit and transform the data into a sparse matrix
        processed_array = preprocessor.fit_transform(df)
        # Retrieve and store the feature names generated by OneHotEncoder
        self.feature_names = preprocessor.get_feature_names_out()
        
        # Return a sparse DataFrame created from the sparse matrix
        return pd.DataFrame.sparse.from_spmatrix(processed_array, columns=self.feature_names)
    
    def _normalize_numerical(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        Normalizes numerical features using StandardScaler.
        
        - Identifies numeric columns in the DataFrame.
        - Converts the numeric portion to dense (if sparse).
        - Applies standard scaling (with with_mean=False to support sparse data).
        - Replaces the original numeric columns with the scaled values.
        
        :param df: Input DataFrame.
        :return: DataFrame with normalized numerical columns.
        """
        # Identify numeric columns
        num_cols = df.select_dtypes(include=np.number).columns
        # Initialize the scaler with with_mean=False (to avoid centering sparse data)
        scaler = StandardScaler(with_mean=False)
        
        # Extract numeric columns; if they are sparse, convert them to dense.
        df_num = df[num_cols]
        if hasattr(df_num, "sparse"):
            df_num = df_num.sparse.to_dense()
        
        # Fit and transform the numeric data
        scaled_array = scaler.fit_transform(df_num)
        # Create a new DataFrame from the scaled data with the same index and column names
        df_scaled = pd.DataFrame(scaled_array, index=df.index, columns=num_cols)
        
        # Replace each numeric column in the original DataFrame with the scaled values
        for col in num_cols:
            df[col] = df_scaled[col]
            
        return df
    
    def _handle_skewness(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        Handles skewed numerical features by applying a logarithmic transformation.
        
        - For each numeric column, computes the skewness.
        - If the absolute skewness is greater than 1.0, applies np.log1p (log(1+x)) transformation.
        
        :param df: Input DataFrame.
        :return: DataFrame with reduced skewness in numeric features.
        """
        # Identify numeric columns
        num_cols = df.select_dtypes(include=np.number).columns
        # Iterate through each numeric column
        for col in num_cols:
            skewness = df[col].skew()  # Calculate skewness
            if abs(skewness) > 1.0:
                df[col] = np.log1p(df[col])
        return df
