import pandas as pd
import numpy as np
from sklearn.preprocessing import StandardScaler, OneHotEncoder
from sklearn.compose import ColumnTransformer
#from sklearn.pipeline import Pipeline  # (This is used for chaining steps)
from loguru import logger  # For logging information, warnings, and errors
from .utils import memory_optimize  # Utility function to optimize DataFrame memory usage

class DataPreprocessor:
    def __init__(self):
        # Initialize variables for the preprocessor and feature names
        # self.preprocessor is currently unused, but can be assigned a pipeline later if needed.
        self.preprocessor = None  
        self.feature_names = []  # To store the names of features after encoding
    
    def preprocess(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        Full preprocessing pipeline that:
        1. Encodes categorical features.
        2. Normalizes numerical features.
        3. Handles skewness in numerical features.
        4. Optimizes DataFrame memory usage.
        
        :param df: Input DataFrame.
        :return: Processed DataFrame.
        """
        logger.info("Starting data preprocessing")
        # Encode categorical features using one-hot encoding
        df = self._encode_categoricals(df)
        # Normalize numerical features using StandardScaler
        df = self._normalize_numerical(df)
        # Apply logarithmic transformation to highly skewed numerical features
        df = self._handle_skewness(df)
        # Optimize DataFrame memory usage (e.g., reducing data types)
        df = memory_optimize(df)
        logger.success("Completed preprocessing")
        return df
    
    def _encode_categoricals(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        Encodes categorical features using one-hot encoding.
        
        - It selects columns of type 'category' or 'object'.
        - Uses ColumnTransformer with OneHotEncoder to convert these columns into binary indicators.
        - The remainder of the DataFrame (non-categorical columns) is passed through unchanged.
        - Stores the new feature names after transformation.
        
        :param df: Input DataFrame.
        :return: DataFrame with categorical features encoded.
        """
        # Select columns that are of type 'object' or 'category'
        cat_cols = df.select_dtypes(include=['category', 'object']).columns
        
        # Create a ColumnTransformer that applies OneHotEncoder to categorical columns
        preprocessor = ColumnTransformer(
            transformers=[
                ('onehot', OneHotEncoder(handle_unknown='ignore'), cat_cols)
            ],
            remainder='passthrough'  # Leave non-categorical columns untouched
        )
        
        # Fit the transformer and transform the DataFrame to a NumPy array
        processed_array = preprocessor.fit_transform(df)
        # Retrieve and store the feature names generated by the OneHotEncoder
        self.feature_names = preprocessor.get_feature_names_out()
        
        # Convert the processed array back to a DataFrame with proper column names
        return pd.DataFrame(processed_array, columns=self.feature_names)
    
    def _normalize_numerical(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        Normalizes numerical features using StandardScaler.
        
        - Identifies numerical columns in the DataFrame.
        - Applies standard scaling (zero mean and unit variance) to these columns.
        
        :param df: Input DataFrame.
        :return: DataFrame with normalized numerical columns.
        """
        # Identify numeric columns
        num_cols = df.select_dtypes(include=np.number).columns
        # Initialize the scaler
        scaler = StandardScaler()
        # Scale the numerical columns and update the DataFrame
        df[num_cols] = scaler.fit_transform(df[num_cols])
        return df
    
    def _handle_skewness(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        Handles skewed numerical features by applying a logarithmic transformation.
        
        - For each numerical column, compute the skewness.
        - If the absolute skewness is greater than 1.0, apply np.log1p (log(1+x)) transformation.
        
        :param df: Input DataFrame.
        :return: DataFrame with reduced skewness in numerical features.
        """
        # Identify numeric columns
        num_cols = df.select_dtypes(include=np.number).columns
        # Iterate through each numeric column
        for col in num_cols:
            skewness = df[col].skew()  # Calculate the skewness
            if abs(skewness) > 1.0:
                # Apply logarithmic transformation if skewness is high
                df[col] = np.log1p(df[col])
        return df